2022.06.23(Thurs)

[TIL] Day41 <br/>
[SEB FE] Day40

오늘부터 Section3 Start 🙌

<br/>

## ☑️ 재귀(recursion)

: 자기 자신을 호출하는 함수

### 📎 재귀로 문제 해결하는 단계

1. 문제를 좀 더 작게 쪼개기
2. 문제가 더이상 작아지지 않을 때까지, 가장 작은 단위로 문제 쪼개기
3. 가장 작은 단위의 문제를 풂 → 전체 문제 해결

```jsx
arrSum([1, 2, 3, 4, 5]) === 1 + arrSum([2, 3, 4, 5]);
arrSum([2, 3, 4, 5]) === 2 + arrSum([3, 4, 5]);
arrSum([3, 4, 5]) === 3 + arrSum([4, 5]);
arrSum([4, 5]) === 4 + arrSum([5]);
arrSum([5]) === 5 + arrSum([]);
arrSum([]) === 0; // 가장 작은 단위
```

```jsx
function arrSum(arr) {
  // 빈 배열일 때 0 리턴 조건문
  // 가장 작은 단위 문제 해결 & 재귀 stop code
  if (arr.length === 0) {
    return 0;
  }

  // 배열 첫 요소(arr.shift()) + 나머지 요소가 담긴 배열을 받는 arrSum()
  return arr.shift() + arrSum(arr);
}
```

<br/>

### 📎 When 재귀 사용?

1. 비슷한 구조의 더 작은 문제로 나눌 수 있는 경우
2. 중첩된 반복문이 많은 경우
3. 반복문의 중첩 횟수를 예측하기 어려운 경우
4. 반복문으로 작성된 코드를 더 간결하고 이해하기 쉽게 작성하고 싶은 경우

- **재귀의 기초**(base case): 재귀 함수를 구현할 때, 재귀의 **탈출 조건**(재귀 호출이 멈추는 조건) 구성
  - 탈출 조건이 없는 경우, 재귀 함수는 끝없이 자기 자신 호출

```jsx
function recursive(input1, input2, ...) {
	// base case: 문제를 더 이상 쪼갤 수 없는 경우 (재귀의 기초)
	if (문제를 더 이상 쪼갤 수 없을 경우) {
		return 단순한 문제 해답;
	}

	// recursive case: 그렇지 않은 경우
	return 더 작은 문제로 새롭게 정의된 문제;
}
```

<br/>
<br/>

---

> 날씨가 꿉꿉해서 그런건지 개발과 벌써 권태기가 온건지 아무것도 하기 싫었던 날.. 격렬하게 그냥 계속 누워있고 싶었다,,<br/>
> 그래도 오늘 배운 내용 정리를 내일로 미루면 내일의 내가 할 일이 넘 많을 것 같아서 일단 적자적자 ✍️ <br/>
> 재귀,, 알듯말듯 문제 혼자 풀어보라고 하면 못 풀둣..🥲
> coplit 재귀 문제 다시 한 번 복습해보면서 벨로그에 다시 정리하기!
