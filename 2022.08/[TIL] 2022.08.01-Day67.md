2022.08.01(Mon)

[TIL] Day67 <br/>
[SEB FE] Day68

<br/>

# ☑️ 컴퓨터 구조

## 📎 입력 장치

> : 컴퓨터가 처리할 수 있는 형태로 데이터와 명령을 받아들이는 물리적 장치 <br/>
> ✔️ 키보드, 마우스, 스캐너, 태블릿 …

## 📎 출력 장치

> : 처리된 데이터를 사람이 이해할 수 있는 형태로 출력하는 물리적인 장치<br/>
> 👉 결과를 화면에 보여주는 장치
> ✔️ 모니터, 프린터

## 📎 중앙처리 장치(`CPU`)

: 연산을 수행하고, 기억장치에 기억되어 있는 명령어들을 수행하는 컴퓨터 시스템의 핵심 부품

- **명령어 인출 / 해독**: 모든 명령어들에 공통 수행 & 기억장치로부터 명령어 읽어옴
- **데이터 인출/처리/쓰기**: 명령어에 따라 필요할 때만 수행

➰ **명령어**란? 시스템이 특정 동작을 수행시키는 작은 단위

- **동작코드**(`Op-code`): 각 명령어 실행 동작을 구분하여 표현
- **오퍼랜드**(`Operand`): 명령어 실행에 필요한 자료 & 실제 자료 저장 위치 의미

🌊 **명령 수행 과정**

1. **읽기**(`Fetch Instruction`; `FI`): 메모리에서 명령 가져옴
2. **해석**(`Decode Instruction`; `DI`): 명령 해석
3. **실행**(`Execute Instruction`; `EI`): 명령 수행
4. **기록**(`Wrtie Back`; `WB`): 수행 결과 기록

### ✨ **산술/논리 연산 장치(Arithmetic Logic Unit, `ALU`)**

> 캐시/메모리로부터 읽어온 데이터는 레지스터에 저장 → 산술 연산 수행

### ✨ **제어장치(Control Unit; `CU`)**

> 프로그램에 따라 명령과 제어 신호 생성→각종 장치 동작 제어

- **프로그램 계수기(`program counter`)**: 프로그램 수행 순서 제어
- **명령 레지스터(`instruction register`)**: 현재 수행 중인 명령어 내용 임시 기억
- **명령 해독기(`instruction decoder`)**: 명령 레지스터에 수록된 명령 해독 → 수행될 장치에 제어신호 보냄

**🫧 제어 장치 구현 방식**

| Hardwired                                                                                                            | Micro Program                                                                                |
| -------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------- |
| - Harwired Circuit에 의해 제어신호가 생성되도록 HW 구성<br/>- 상태계수기 & PLA(Programmable Logic Array) 회로로 구성 | 발생 가능한 제어 신호들의 조합을 미리 구성<br/>→ ROM에 저장 → 필요시 신호 발생시키는 SW 방식 |
| 고속 처리 & expensive                                                                                                | 속도 ⬇️ & cheap                                                                              |
| RISC에 적용                                                                                                          | CISC에 적용                                                                                  |

🌊 **명령어 처리 방식**

- **`RISC`**(`Reduced Instruction Set Computer`)<br/>
  : 컴퓨터 내부적으로 사용하는 명령어 세트를 단순화시켜서 처리하는 형태 구조 - 단순 명령 조합 → 하나의 기능 수행 - 하나의 Cycle로 명령어 처리 - 메모리 Load / Store 명령만 처리하는 방식 - 파이프라이닝, 슈퍼스칼라 사용 가능 - 복잡한 컴파일러 구조
  <br/>

- **`CISC`**(`Complex Instruction Set Computer`)<br/>
  : 하나의 기능에 해당하는 하나의 명령 - 여러 Cycle로 명령어 처리 - 많은 명령어가 메모리를 참조하는 처리 방식 - 파이프라이닝 사용 어렵 - 복잡한 마이크로 프로그램 구조

### ✨ **Register**

> : CPU 내부 메모리(기억장치)로서 CPU에서 사용하는 데이터를 일시적으로 저장하는 장소

- **`IR`**(`Instruction Register`): 현재 수행 중에 있는 명령어 부호를 저장하고 있는 레지스터
- **`PC`**(`Program Counter`): 명령이 저장된 메모리 주소를 가리키는 레지스터
- **`AC`**(`Accumulator`): 산술/논리 연산 결과를 임시로 기억하는 레지스터

<br/>

## 📎 저장 장치

### ✨ 주기억장치(`Memory`)

> : 데이터나 프로그램을 보관하기 위한 기억 장치 <br/>
>
> - 정보를 저장해 두었다가 필요할 때 읽어들이는 저장소로 사용
> - 시스템 활성화된 상태에서 그 값 기억 But, 시스템 OFF → ShutDown (값 지워짐)

- `RAM`(Random Access Memory)
  - 컴퓨터 전원 OFF → 내용 휘발 → 보조 저장장치 꼭 필요!
  - RAM 크기는 프로그램 수행 속도에 영향을 줌
  - CPU에서 직접 접근 가능한 유일한 저장 장치
- `ROM`(Read Only Memory): 대부분 읽을 수만 있는 장치로 구성되어 있으며, 전원 OFF → 내용 보존

   <br/>

**🌊 Memory 성능**

- 메모리 속도: 메모리가 CPU와 데이터를 주고받는 시간 ⇒ `액세스` (ns; nano second)<br/>
  👍 속도가 빠를수록 성능이 좋다!

  - `리프레시 시간`: 일정 시간마다 메모리를 재충전해줘야 하는 시간
    - 메모리에서 한번 읽고 나서 ~ 다시 읽을 수 있는 사이의 시간
  - `메모리 액세스 시간`: 데이터 읽어오라는 명령을 받고 ~ 데이터를 읽기 시작하기까지의 시간
    - CPU에서 명령어 처리시 명령어가 갖는 주소 send → CPU에 주소의 해당 값을 가져오는데 걸리는 시간
  - `사이클 시간`(리프레시 시간 + 메모리 액세스 시간)
    - 메모리 작업 완료와 동시에 대기 신호 내보냄
      → 다음 신호를 받을 준비가 되었다는 신호를 주기까지의 시간

### ✨ **보조** 기억장치

> 주기억 장치를 보조하기 위한 장치

- 기억된 내용을 읽는 속도 Slow But, 대용량 기억 가능
- 현재 사용하지 않는 프로그램 저장
- 시스템 OFF → 기억하고 있는 값 휘발 ❌
  - `자기 디스크`: 원판 표면 철 입자 방향(N/S극)으로 0, 1 표현
    - 디스크 드라이브: 자기 디스크로부터 데이터를 읽는 주변 장치 의미
    - ex. 플로피 디스크(FDD), 하드 디스크(HDD)
  - `광 디스크`(Optical disc, OD): 빛의 반사를 이용해 자료를 읽어내는 저장 매체
    - ex. CD → DVD → 블루레이 디스크
  - `플래시 메모리`: 전자적으로 데이터를 지우고 쓸 수 있는 비휘발성 메모리로 충격에 강하며 휴대용 기기로 사용
    - ex. USB, SSD(저전력, 저소음, 저중량)

<img width="578" alt="스크린샷 2022-08-01 오전 10 58 50" src="https://user-images.githubusercontent.com/64299610/182219344-6f794366-60c1-4a8d-9bf1-880152f373bb.png">

<br/>

### ✨ Cache Memory

> : 메인 메모리(slow)와 CPU(fast) 간의 데이터 속도 향상을 위한 중간 버퍼 역할

**🌊 캐시 메모리 성능 결정 요소**

- Block / Word 사이즈가 상대적으로 크다면 ⬆️ Cache의 `Hit Ratio율` ⬆️ → 캐시 성능에 영향

  - `Cache Hit`: 필요 데이터가 캐시 메모리 내에 들어와 있는 경우
  - `Cache Miss`: 접근하고자 하는 데이터가 없을 경우<br/>
    👉 `Hit Ratio`: 원하는 데이터가 캐시에 있을 확률

  | 요소                            | 내용                                                                                                                                                              |
  | ------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | Cache 크기                      | 캐시 메모리 size가 크면 → Hit Ratio율과 반비례                                                                                                                    |
  | 인출 방식<br/>(Fetch Algorithm) | - 요구 인출(Demand Fetch): 필요시 요구하여 인출하는 방식<br/>- 선 인출(Pro-Fetch): 예상되는 데이터를 미리 인출하는 방식                                           |
  | 쓰기 정책<br/>(Wrtie Policy)    | - Write-Through: 주기억 장치와 캐시에 동시에 쓰는 방식. 캐시와 메모리 내용 항상 일치 (구성 방법 단순)<br/>- Write-Back: 데이터 변경만 캐시에 기록하는 방식 (복잡) |
  | 교체(Replace) 알고리즘          | Cache Miss 발생시 기존 메모리와 교체하는 방식<br/>ex. FIFO, LRU, Random, Optimal Belady’s MIN …                                                                   |
  | 사상(Mapping) 기법              | 주기억장치 블록을 적재할 캐시 내의 위치 지정 방법<br/>ex. direct, associative, set associative maaping …                                                          |

<br/>

---

## ☑️ 운영체제(OS)

**🌊 OS 기능**

- 프로세서, 기억장치, 입출력장치, 파일/정보 등의 자원 관리

  - 시스템 자원 관리
    - 프로세스 관리 (CPU)
    - 메모리 관리
    - I/O(입출력) 관리 (Disk, Network …)
  - 응용 프로그램 관리: 응용 프로그램이 실행되고, 시스템 자원을 사용할 수 있도록 권한 & 사용자 관리

    ➰ `응용 프로그램`: 운영체제를 통해 컴퓨터에게 일을 시키는 것
    → 컴퓨터 조작 가능 권한을 운영체제로부터 부여받아야 함 → 기능 이용 가능

    - 운영체제는 응용 프로그램을 위해 인터페이스(API) 제공해야 함

    ➰ `System Call`: 응용 프로그램이 시스템 자원을 사용할 수 있도록, 운영체제 차원에서 다양한 함수를 제공하는 것

- 자원을 효율적으로 관리하기 위해 자원 스케줄링 기능 제공
  - `스케줄링`: 어떤 자원을 누가, 언제, 어떤 방식으로 사용할지 결정해주는 것
- 사용자와 시스템 간의 편리한 인터페이스 제공
- 시스템의 각종 하드웨어와 네트워크 관리 제어

<br/>

## 📎 프로세스

: 프로그램이 실행 중인 상태로 CPU가 해당 명령어를 하나씩 수행하고 있는 상태<br/>
👉 실행 중인 하나의 애플리케이션

✋ 크롬 브라우저 2개 실행 → 2개 프로세스 생성 즉, 하나 애플리케이션이 다중 프로세스 생성하기도 함

### ✨ 프로세스 구성 요소

1. `유저 메모리 영역 관리` (Virtual Address Descriptors)
   : 프로세스별로 독립된 영역을 가지게 되는 곳
   - 커널 메모리 공간의 경우, 모든 프로세스가 공유하여 사용
     <br/>
2. `Handle Table`
   : 프로세스에서 사용하는 모든 핸들에 대한 커널 객체 포인터 정보를 배열 형태로 가지고 있는 공간
   - 프로세스 종료시 이 테이블 정보를 참고하여 사용하고 있는 모든 커널 객체를 자동으로 반환
     <br/>
3. `독립적인 메모리 공간`
   : 페이징 기법을 이용하여 프로세스마다 별도의 고유한 메모리를 사용할 수 있도록 함 (window)

### ✨ 프로세스 특징

- `자원 소유 단위`: 해당 프로세스가 접근하고자 하는 파일, I/O 장치들에 대해서 프로세서 단위로 할당받아 관리되어야 함
- `디스패칭 단위` = `Thread`: 한 프로그램이 운영체제로부터 CPU 자원을 일정 기간동안 할당받아 명령어를 실행하는 것
  - OS는 여러 프로세스가 병렬적으로 실행되도록 CPU 사용 시간을 각 프로세스에 골고루 나눠줘야 함

### ✨ 프로세스 상태

- 실행(`Run`): 프로세스가 프로세서를 차지하여 서비스를 받고 있는 상태
- 준비(`Ready`): 실행될 수 있도록 준비되는 상태
- 대기(`Waiting`): CPU 사용이 아닌 입출력을 기다리는 상태

### ✨ `Processor` vs `Process`

🫧 `Processor`

- HW 측면: 컴퓨터 내에서 프로그램을 수행하는 하드웨어 유닛으로 `CPU` 의미
  - ALU & Register 내장
- SW 측면: 데이터 포맷 변환 역할을 수행하는 데이터 처리 시스템을 의미
  - 워드프로세서, 컴파일러 등 포함

🫧 `Process`

: 특정 목적을 수행하기 위해 나열된 작업 목록을 의미<br/>
👉 메모리에 적재되어 프로세서에 의해 실행 중인 프로그램

<br/>

## 📎 Thread

: CPU를 통해서 명령어가 수행되는 객체 단위<br/>
✋ 하나의 프로세스 내에는 반드시 1개 이상의 스레드 존재! → 같은 프로세스에 있는 자원 & 상태 공유

- 같은 프로세스 내에 있는 스레드는 같은 주소 공간에 존재 → 동일 데이터에 접근 가능
- 독립적으로 수행하여 처리하려고 할 때 스레드 사용!<br/>
  👉 즉, 여러 개의 작업 단위로 구성된 프로그램에서 요청을 동시에 처리하기 위해서

### ✨ Thread 구성 요소

- `가상 CPU`: 인터프리터, 컴파일러에 의해 내부적으로 처리되는 가상 코드
- `수행 코드`: Thread Class에 구현되어 있는 `run()` Method code
- `처리 데이터`: Thread에서 처리하는 데이터

### ✨ Thread 특징

- 프로세스 내에서 실행되는 흐름 단위
- 하나의 스레드는 시작~종료동안 한번에 하나씩 명령들을 수행
- 각 스레드마다 `call stack` 존재
  - `call stack`: 실행 중인 서브루틴을 저장하는 자료 구조<br/>
    ✋ 프로세스는 다른 프로세스의 메모리에 직접 접근 ❌
- 다른 스레드와 독립적으로 동작
  - 2개 이상의 스레드 동작시, 실행 / 종료 순서 예측 ❌

### 🌊 Single-Thread

: 단일 스레드만으로 직렬 처리하는 프로그래밍 방법 - ex. JS<br/>
👉 한 프로세스는 오직 한 프로세서에서만 수행 가능

👍 **Single Thread 장점**

- 자원 접근의 동기화 신경 ❌ → 문맥 교환 작업 요구 ❌
  - 스레드들이 동시에 같은 자원에 접근 못하도록 제어해줘야 함
- 프로그래밍 난이도 easy, CPU 메모리 적게 사용

> 🫧 `문맥 교환`(`Context switching`)
>
> - 여러 개의 프로세스가 하나의 프로세서를 공유할 때 발생하는 작업
> - 다른 Task(`Process`, `Thread`)가 시작할 수 있도록 이미 실행 중인 Task를 멈추는 것

👎 **Single Thread 단점**

- 여러 개의 CPU 활용 못함..
  - 최적화를 위해선 `Cluster` 모듈 이용 → 여러 프로세스 사용 가능
- 연산량이 많은 작업의 경우, 그 작업이 완료되어야 다른 작업 수행 가능
- 에러 처리를 못하는 경우 멈춤

### 🌊 Multi-Thread

: 하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행하는 것
👉 여러 개의 CPU를 사용하여 여러 프로세스를 동시에 수행하는 것을 의미

👍 **Multi-Thread 장점**

- 작업을 분리해서 수행 → 실시간으로 사용자에게 응답 가능
- 한 프로세스를 여러 프로세서에서 수행 가능 → 훨씬 효율적

**👎 Multi-Thread 단점**

- 주의 깊은 설계 필요, 디버깅 까다롭,,
- 단일 프로세스 시스템의 경우 효과를 기대 어렵. 다른 프로세스에서 스레드 제어 ❌
  👉 즉, 프로세스 밖에서 스레드 각각 제어 ❌
- 자원 공유 문제 발생 (하나의 스레드에 문제 발생 → 전체 프로세스 영향)
- 문맥 교환 작업 요구

### 🎃 **동시성 & 병렬성 차이**

- 동시에 돌릴 수 있는 스레드 수 - 컴퓨터에 있는 코어 개수로 제한
- OS는 각 스레드를 시간에 따라 분할 → 여러 스레드가 일정 시간마다 돌아가면서 실행되도록 ⇒ `시분할`
  - `Concurrency`(동시성, 병행성): 여러 개의 스레드가 시분할 방식으로 동시에 수행되는 것처럼 착각
  - `Parallelism`(병렬성): 멀티 코어 환경에서 여러 개의 스레드가 실제로 동시에 수행

---

## ☑️ 문자열

### 📎 Unicode

: 유니코드 협회가 제정하는 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준

✨ **인코딩(부호화)**: 어떤 문자나 기호를 컴퓨터가 이용할 수 있는 신호로 만드는 것

🫧 **문자열 세트 / 문자셋(charset)**: 인코딩 & 디코딩 기준

### 📎 ASCII 문자

: 영문 알파벳을 사용하는 대표적인 문자 인코딩 (`7bit`로 모든 영어 알파벳 표현)
✋ 유니코드는 ASCII를 확장한 형태

### 📎 UTF-8

: 가변 길이 인코딩으로써, `Byte` 순서 고정

- 한 문자를 나타내기 위해 1byte(=8bits) ~ 4bytes까지 사용
- 한글-3byte

### 📎 UTF-16

: 코드 그대로 `Byte`로 표현 가능, `Byte` 순서 다양

- `16bits`(`2bytes`)로 표현
- 한글-`2byte`

---

## ☑️ 그래픽

### 📎 Bitmap

: 웹 상에서 디지털 이미지를 저장하는 데에 가장 많이 쓰이는 이미지 파일 포맷 형식 (= 래스터(점 방식))

- 이미지 각 점들을 격자형 pixel 단위로 구성
- 컴퓨터에게 부담을 덜 주는 구조
- 계단 현상 / 깨짐 현상 발생
- 경계가 뚜렷하지 않음
- pixel 하나 당 색상 값을 모두 가지고 있기 때문에 이미지 사이즈가 커질수록 용량도 무거워짐

### 📎 Vector

: 이미지를 수학적인 공식으로 표현

- 아무리 확대해도 계단현상 / 깨짐현상 발생 ❌
- 컴퓨터에게 부담을 가하는 방식 → 도형, 글자 그리는 작업에 사용
- 사이즈를 키워도 용량은 변화 ❌

|                       | Bitmap(Raster)                   | Vector                                                  |
| --------------------- | -------------------------------- | ------------------------------------------------------- |
| 기반 기술             | pixel 기반                       | 수학적으로 계산된 Shape 기반                            |
| 특징                  | 색상 조합이 다양한 이미지에 적합 | 로고, 일러스트와 같이 제품에 적용되는 이미지에 적합     |
| 확대                  | 확대 적합 ❌                     | 품질 저하 없이 모든 크기로 확대 가능<br/>해상도 영향 ❌ |
| 크기에 따른 파일 용량 | 큰 크기 이미지 → 큰 파일 사이즈  | 큰 크기 벡터 그래픽 → 작은 파일 사이즈 유지 가능        |
| 상호 변환             | 백터로 변환하는데 오래걸림       | 쉽게 래스터 이미지로 변환 가능                          |
| 파일 포맷             | jpg, gif, png, bmp, psd          | svg, ai                                                 |

<br/>

---

## ☑️ Garbage Collection

> : 프로그램에서 더 이상 사용하지 않는 메모리를 자동으로 정리하는 것 <br/>
> ㄴ ex. `Java`, `C#`, `JavaScript`

### 🌊 Garbage Collection 방법

- `트레이싱`: 한 객체에 flag를 두고, 가비지 컬렉션 사이클마다 flag에 표시 후 삭제하는 `mark and sweep` 방법
  - 객체에 `in-use flag`를 두고, 사이클마다 메모리 관리자가 모든 객체를 추적해서 사용 중인지 아닌지를 표시(`mark`). 그 후 표시되지 않은 객체를 삭제(`sweep`)하는 단계를 통해 메모리를 해제
- `레퍼런스 카운팅`: 한 객체를 참조하는 변수의 수를 추적하는 방법
  - 변수 레퍼런스 복사될 때 마다 레퍼런스 카운트 늘어남
  - 객체 참조 변수 값이 바뀌거나, 변수 스코프를 벗어나면 레퍼런스 카운트 줄어듬.
  - 레퍼런스 카운트 0: 객체와 관련한 메모리 비울 수 있음. 그 객체에 대한 레퍼런스 가지고 있지 않음

## ☑️ Cache

: 많은 시간이나 연산이 필요한 작업의 결과를 저장해두는 것<br/>
👉 일시적인 데이터를 저장하기 위한 목적으로 존재하는 고속의 데이터 저장 공간

- 이전에 검색하거나 계산한 데이터를 효율적으로 재사용 가능
- 캐시 데이터는 빠르게 액세스 가능한 하드웨어에 저장
- 속도를 위해 용량을 절충하는 캐시는 데이터의 하위 집합을 일시적으로 저장

### 👍 캐시 장점

- 애플리케이션 성능 개선
- 데이터베이스 비용 절감
- 백엔드 부하 ⬇️
- 예측 가능한 성능
- 데이터베이스 핫스팟 제거
- 읽기 처리량 증가
